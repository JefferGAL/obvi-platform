#!/usr/bin/env python3
"""
Trademark Report Generator with Multi-Factor Risk Breakdown and AI Summaries
"""
import logging
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional

from llm_integration import OllamaClient
from common_law_integration import CommonLawReportIntegration
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class SearchParameters:
    """Capture all search parameters and AI decisions"""
    trademark: str
    questionnaire_responses: Dict[str, Any]
    ai_recommended_classes: List[int]
    ai_reasoning: str
    coordination_applied: List[str]
    search_variations: Dict[str, List[str]]
    thresholds: Dict[str, float]
    search_mode: str
    analysis_method: str
    selected_classes: List[int] = None

class TrademarkReportGenerator:
    """Generates comprehensive, legally intelligent trademark search reports."""
    
    def __init__(self):
        self.llm_client = OllamaClient()
        self.common_law_integrator = CommonLawReportIntegration()
        self.disclaimer = """
**IMPORTANT LEGAL DISCLAIMER**

This report is generated by Obvi's trademark search system and serves as a **STARTING POINT** for trademark clearance analysis. This is **NOT** a comprehensive clearance search and does **NOT** constitute legal advice.

**CONSULT AN ATTORNEY:** You should meet with a qualified trademark attorney to:
- Review state trademark databases and common law rights
- Assess mitigating circumstances specific to your situation
- Conduct international searches if you plan global expansion
- Provide professional legal guidance on registration strategy

**LIMITATIONS OF THIS SEARCH:**
- Federal trademark database only - does not include state registrations
- Does not search common law trademark rights
- International trademark databases not included
- Domain name conflicts not comprehensively analyzed
- Industry-specific trademark usage not fully covered

This analysis helps determine if it's rational to invest thousands in comprehensive clearance for a particular mark, but is **not a substitute for professional legal counsel**.
"""
        logger.debug("TrademarkReportGenerator initialized")

    # 09072025 - The function signature is updated to expect the SearchParameters class instance
    # instead of a generic dictionary.
    def generate_report(
        self, 
        search_params: SearchParameters, 
        search_results: Dict, 
        common_law_results: Optional[Dict[str, Any]] = None
    ) -> Dict:
        """Generates the full report with AI summaries."""
        # ANNOTATION: Access attributes directly using dot notation (e.g., .trademark)
        # instead of the .get() method.
        logger.info(f"Generating report for trademark: {search_params.trademark}")
        
        # - should really allow for basic or enhanced
        markdown_content = self._generate_report_header(search_params, "ENHANCED")
        markdown_content += self._generate_search_context_section(search_params)
        
        if search_results.get('matches'):
            markdown_content += self._format_conflict_analysis(search_results['matches'])
        else:
            markdown_content += "## No Direct Conflicts Found\n\nNo potential conflicts were found in the federal database based on the search criteria.\n"
        
        if common_law_results and common_law_results.get('success'):
            logger.info("Appending common law results to the report.")
            markdown_content += self.common_law_integrator.get_disclaimer()
            markdown_content += self.common_law_integrator.generate_common_law_section(common_law_results)
            
        return {
                "report_metadata": self._generate_report_metadata("enhanced"),
                "report_content": markdown_content,
                "disclaimer_included": True,
                "ai_analysis_used": self.llm_client.check_connection(),
                "analysis_type": "hybrid_rule_ai",
                "filename_label": "enhanced_tm_search_report",
                "common_law_included": bool(common_law_results and common_law_results.get('success'))
            }

    # ANNOTATION: Helper methods are also updated to use dot notation.
    def _generate_report_header(self, params: SearchParameters, report_type: str) -> str:
        return f"""# Obvi Trademark Search Report - {report_type} ANALYSIS
**Trademark Analyzed:** {params.trademark}
**Generated:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')}
***
{self.disclaimer}
***
"""
    
    def _generate_search_context_section(self, params: SearchParameters) -> str:
        """Formats the search context section based on questionnaire responses."""
        markdown = "## Search Context & Parameters\n\n"
        markdown += "This search was guided by the following user-provided information:\n\n"
        
        # ANNOTATION: Accessing the nested questionnaire object directly.
        q_responses = params.questionnaire_responses or {}
        
        markdown += f"- **Core Business / Offering:** {q_responses.get('core_offering', 'Not provided')}\n"
        markdown += f"- **Brand Identity:** {q_responses.get('brand_identity', 'Not provided')}\n"
        markdown += f"- **Target Market:** {q_responses.get('target_market', 'Not provided')}\n"
        markdown += f"- **Expansion Plans:** {q_responses.get('expansion_plans', 'Not provided')}\n"
        
        if params.selected_classes:
            markdown += f"- **Searched NICE Classes:** {', '.join(map(str, params.selected_classes))}\n\n"
        
        markdown += "***\n\n"
        return markdown

    def _format_conflict_analysis(self, matches: List[Dict]) -> str:
        """Formats the detailed conflict analysis section for the report."""
        markdown = "## Federal Database Conflict Analysis\n\n"
        
        high_risk_matches = [m for m in matches if m.get('risk_level') == 'high']
        
        # Generate AI Summary for the overall situation
        if high_risk_matches:
             markdown += f"**Overall AI Assessment:** High risk. Found {len(high_risk_matches)} significant conflicts in the federal database requiring immediate review.\n\n"
        else:
            markdown += "**Overall AI Assessment:** Low to Medium risk. No high-risk conflicts were identified in the federal database, but review of all findings is recommended.\n\n"

        for i, conflict in enumerate(matches, 1):
            markdown += f"### Federal Conflict #{i}: **{conflict.get('mark_identification', 'Unknown')}**\n\n"
            markdown += f"- **Owner:** {conflict.get('owner', 'Unknown')}\n"
            markdown += f"- **Status:** {conflict.get('status_code', 'Unknown')}\n"
            markdown += f"- **Final Risk Level:** {conflict.get('risk_level', 'unknown').upper()}\n\n"
            
            # Add the structured risk breakdown
            risk_analysis = conflict.get('risk_analysis', {})
            if risk_analysis:
                markdown += "**Risk Analysis Breakdown:**\n"
                if risk_analysis.get('status_impact'):
                    markdown += f"- **Status Factor:** {risk_analysis.get('status_impact')}\n"
                if risk_analysis.get('threshold_breach'):
                    markdown += f"- **Similarity Factor:** {risk_analysis.get('threshold_breach')}\n"
            
            # Call the LLM to generate the narrative summary for high-risk items
            if conflict.get('risk_level') == 'high' and self.llm_client.check_connection():
                try:
                    ai_summary = self.llm_client.generate_ai_analyst_summary(conflict)
                    markdown += f"\n**AI Analyst's Summary:**\n> {ai_summary}\n\n"
                except Exception as e:
                    logger.error(f"Failed to generate AI summary for {conflict.get('serial_number')}: {e}")

            markdown += "\n"
        
        return markdown

    def _generate_report_metadata(self, report_type: str) -> Dict[str, Any]:
        """Generates metadata for the report."""
        return {
            "version": "2.0",
            "generated_at": datetime.now(timezone.utc).isoformat(),
            "report_type": report_type
        }